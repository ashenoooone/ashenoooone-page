<div class="inset-0 fixed bg-black pointer-events-none w-full h-full">
  <canvas class="w-full h-full" id="dots" aria-hidden="true"></canvas>
</div>

<script>
  const canvas = document.getElementById('dots') as HTMLCanvasElement
  const ctx = canvas.getContext('2d')!

  const GAP = 25
  const RADIUS = 1.5
  const SPEED_MULTIPLIER = 0.4
  const AMP_MULTIPLIER = 2.5
  const BASE_SPEED = 0.3
  const BASE_AMP = 1.5
  const COLOR = 'rgba(255,255,255,'

  interface Dot {
    bx: number // base x
    by: number // base y
    ox: number // offset x
    oy: number // offset y
    vx: number // velocity x
    vy: number // velocity y
    phase: number
    speed: number
    amp: number
  }

  let dots: Dot[] = []
  let cols = 0
  let rows = 0
  let raf: number
  function buildGrid() {
    cols = Math.ceil(canvas.width / GAP) + 1
    rows = Math.ceil(canvas.height / GAP) + 1

    // padding чтоб сетка начиналась чуть за краем и покрывала весь экран
    const offX = (canvas.width - (cols - 1) * GAP) / 2
    const offY = (canvas.height - (rows - 1) * GAP) / 2

    dots = []
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        dots.push({
          bx: offX + c * GAP,
          by: offY + r * GAP,
          ox: 0,
          oy: 0,
          vx: 0,
          vy: 0,
          phase: Math.random() * Math.PI * 2,
          speed: BASE_SPEED + Math.random() * SPEED_MULTIPLIER, // рад/сек
          amp: BASE_AMP + Math.random() * AMP_MULTIPLIER, // макс смещение в px
        })
      }
    }
  }

  function resize() {
    canvas.width = window.innerWidth
    canvas.height = window.innerHeight
    buildGrid()
  }

  let last = 0
  function frame(ts: number) {
    const dt = Math.min((ts - last) / 1000, 0.05) // сек, max 50ms
    last = ts

    ctx.clearRect(0, 0, canvas.width, canvas.height)

    for (const d of dots) {
      // плавное синусоидальное колебание по двум осям с разными фазами
      d.phase += d.speed * dt
      d.ox = Math.sin(d.phase) * d.amp
      d.oy = Math.cos(d.phase * 0.7 + 1.3) * d.amp

      const x = d.bx + d.ox
      const y = d.by + d.oy

      // прозрачность слегка пульсирует вместе с колебанием
      const opacity = 0.18 + 0.12 * Math.sin(d.phase * 1.3)

      ctx.beginPath()
      ctx.arc(x, y, RADIUS, 0, Math.PI * 2)
      ctx.fillStyle = `${COLOR + opacity})`
      ctx.fill()
    }

    raf = requestAnimationFrame(frame)
  }

  resize()
  window.addEventListener('resize', resize)
  raf = requestAnimationFrame((ts) => {
    last = ts
    frame(ts)
  })
  document.addEventListener('astro:before-swap', () => {
    cancelAnimationFrame(raf)
    window.removeEventListener('resize', resize)
  })
</script>
